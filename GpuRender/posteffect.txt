
texture Texture0;
sampler2D sourceSampler0 =
sampler_state
{
	Texture = <Texture0>;
	AddressU = Wrap;
	AddressV = Wrap;
	MinFilter = Point;
	MagFilter = Linear;
	MipFilter = Linear;
};
		
struct VS_INPUT
{
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

struct VS_OUTPUT
{
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VS_OUTPUT vs_quad( VS_INPUT vert )
{
	VS_OUTPUT vsout = (VS_OUTPUT)0;
	vsout.pos = vert.pos;
	vsout.uv = vert.uv;
	return vsout;
}

float width;
float height;
float step;
float radius;


struct PS_OUTPUT
{
	float4 Color:COLOR;
};

PS_OUTPUT ps_beauty0( float2 texCoord  : TEXCOORD0 )
{
	PS_OUTPUT psout = (PS_OUTPUT)0;
	float uBoxHeight = radius / height;
	float uYStep = step / height;
	float4 sum = float4(0.0, 0.0, 0.0, 0.0);
	float halfH = uBoxHeight / 2.0;
	int num = 0;
	for (float j = -halfH; j < halfH; j += uYStep)
	{
		float4 pixel = tex2Dgrad(sourceSampler0, texCoord + float2(0, j), 1 / width, 1 / height);

		pixel.a = 1.0;
		float skinVal = 0.0;
		float cb = dot(float4(-37.74, -74.205, 111.945, 128.0), pixel);
		float cr = dot(float4(111.945, -93.84, -18.105, 128.0), pixel);
		float maxSkinVal = 110.0;
		float skinValueCb = (maxSkinVal - abs(cb - 102.0)) / maxSkinVal;
		float skinValueCr = (maxSkinVal - abs(cr - 153.0)) / maxSkinVal;
		pixel.a = pow((skinValueCb + skinValueCr) * 0.5, 2.0);

		sum += pixel;
		num ++;
	}

	psout.Color = sum / float(num);
	return psout;
}

technique vpProcess
{
	pass beauty0
	{
		VertexShader =  compile vs_3_0 vs_quad();
		PixelShader  =  compile ps_3_0 ps_beauty0();
		ZEnable = false;
	}

}






















